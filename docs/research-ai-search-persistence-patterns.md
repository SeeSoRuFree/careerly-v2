# AI ê²€ìƒ‰ ì„œë¹„ìŠ¤ ëŒ€í™”/ê²€ìƒ‰ ê²°ê³¼ ì˜ì†í™” ë° ê³µìœ  íŒ¨í„´ ì—°êµ¬

> ì—°êµ¬ ì¼ì: 2025-12-04
> ëŒ€ìƒ ì„œë¹„ìŠ¤: Perplexity AI, ChatGPT, ê¸°íƒ€ AI ê²€ìƒ‰ ì„œë¹„ìŠ¤

## ëª©ì°¨
1. [URL íŒ¨í„´ ë¶„ì„](#1-url-íŒ¨í„´-ë¶„ì„)
2. [ê¸°ìˆ  êµ¬í˜„ íŒ¨í„´](#2-ê¸°ìˆ -êµ¬í˜„-íŒ¨í„´)
3. [ìŠ¤íŠ¸ë¦¬ë° + ì˜ì†í™” ë™ì‹œ ì²˜ë¦¬](#3-ìŠ¤íŠ¸ë¦¬ë°--ì˜ì†í™”-ë™ì‹œ-ì²˜ë¦¬)
4. [Best Practices](#4-best-practices)
5. [êµ¬í˜„ ê¶Œì¥ì‚¬í•­](#5-êµ¬í˜„-ê¶Œì¥ì‚¬í•­)

---

## 1. URL íŒ¨í„´ ë¶„ì„

### 1.1 Perplexity AI URL êµ¬ì¡°

#### ê¸°ë³¸ ê²€ìƒ‰ URL
```
https://www.perplexity.ai/search/?q={query}
ë˜ëŠ”
https://www.perplexity.ai/search/{query-slug}
```

#### Perplexity Pages (ê³µìœ  ê°€ëŠ¥í•œ ì½˜í…ì¸ )
- **ëª©ì **: ê²€ìƒ‰ ê²°ê³¼ë¥¼ ì‹œê°ì ìœ¼ë¡œ ì •ë¦¬ëœ í˜ì´ì§€ë¡œ ë³€í™˜
- **íŠ¹ì§•**:
  - Google ê²€ìƒ‰ ê°€ëŠ¥ (SEO ìµœì í™”)
  - ê³µìœ  ë§í¬ ì œê³µ
  - ê¸°ì¡´ ëŒ€í™”ë¥¼ Pagesë¡œ ë³€í™˜ ê°€ëŠ¥
  - Follow-up ì§ˆë¬¸ ì§€ì›

#### Spaces (í˜‘ì—… ê¸°ëŠ¥)
- ê²€ìƒ‰ ê²°ê³¼ë¥¼ Spacesì— ì €ì¥í•˜ì—¬ ì¬ë°©ë¬¸ ë° ê³µìœ  ê°€ëŠ¥
- íŒ€ ë‹¨ìœ„ ë‚´ë¶€ ì§€ì‹ ê´€ë¦¬
- ê²€ìƒ‰ ì—”ì§„ + ì§€ì‹ ë² ì´ìŠ¤ ê²°í•© í˜•íƒœ

**ì°¸ê³  ë¬¸ì„œ**:
- [Perplexity AI's new feature will turn your searches into shareable pages](https://techcrunch.com/2024/05/30/perplexity-ais-new-feature-will-turn-your-searches-into-sharable-pages/)
- [Getting Started with Perplexity](https://www.perplexity.ai/hub/getting-started)

---

### 1.2 ChatGPT ê³µìœ  ê¸°ëŠ¥

#### URL íŒ¨í„´
```
https://chatgpt.com/share/{uuid}
```

**ì˜ˆì‹œ**:
```
https://chatgpt.com/share/d1c31390-cf22-42f5-b30e-cc4f9e517700
```

#### ì£¼ìš” íŠ¹ì§•

**1. Permalink ìƒì„± ë°©ì‹**
- ì‚¬ì´ë“œë°” ë˜ëŠ” ìš°ì¸¡ ìƒë‹¨ ê³µìœ  ë²„íŠ¼ìœ¼ë¡œ ìƒì„±
- UUID ê¸°ë°˜ ê³ ìœ  ID
- ì›¹, iOS, Android ì•± ëª¨ë‘ ì§€ì›

**2. ë¯¸ë¦¬ë³´ê¸° ë° ê³µìœ **
- ì›¹ì—ì„œëŠ” ê³µìœ  ì „ ëŒ€í™” ìŠ¤ëƒ…ìƒ· ë¯¸ë¦¬ë³´ê¸° ì œê³µ
- ì†Œì…œ ë„¤íŠ¸ì›Œí¬ì— ì§ì ‘ ê³µìœ  ì˜µì…˜

**3. ì ‘ê·¼ ì œì–´**
- í˜„ì¬ ì„¸ë¶„í™”ëœ ê¶Œí•œ ê´€ë¦¬ ì—†ìŒ
- ë§í¬ë¥¼ ì•„ëŠ” ëª¨ë“  ì‚¬ëŒì´ ì ‘ê·¼ ê°€ëŠ¥

**4. Continue Conversation ê¸°ëŠ¥**
- ê³µìœ  ë§í¬ë¥¼ ë°›ì€ ì‚¬ëŒì´ ëŒ€í™”ë¥¼ ì´ì–´ê°ˆ ìˆ˜ ìˆìŒ
- ì›ë³¸ ëŒ€í™”ì—ëŠ” ì˜í–¥ ì—†ì´ ë…ë¦½ì ìœ¼ë¡œ ì§„í–‰

**5. ì‚­ì œ ë™ì‘**
- ì›ë³¸ ëŒ€í™” ì‚­ì œ ì‹œ ê³µìœ  ë§í¬ë„ ì‚­ì œë¨
- ê³µìœ  ë§í¬ë¥¼ í†µí•œ ì ‘ê·¼ ë¶ˆê°€ëŠ¥í•´ì§

**6. ë§í¬ ê´€ë¦¬**
- Settings > Data controls > Shared linksì—ì„œ ê´€ë¦¬
- ìƒì„±ëœ ëª¨ë“  ê³µìœ  ë§í¬ í™•ì¸ ë° ê´€ë¦¬ ê°€ëŠ¥

**ì°¸ê³  ë¬¸ì„œ**:
- [ChatGPT Shared Links FAQ](https://help.openai.com/en/articles/7925741-chatgpt-shared-links-faq)
- [How to Share ChatGPT Conversation via Shared Link](https://updf.com/chatgpt/share-chatgpt-conversation/)

---

### 1.3 URL ì „í™˜ íŒ¨í„´ ë¹„êµ

| ì‹œë‚˜ë¦¬ì˜¤ | ê¶Œì¥ ë°©ë²• | ì´ìœ  |
|---------|---------|------|
| ê²€ìƒ‰ ì‹œì‘ (ìµëª…) | `/search` | ì„ì‹œ ì„¸ì…˜ ì‹œì‘ |
| ê²°ê³¼ ë¡œë”© ì™„ë£Œ | `history.replaceState` â†’ `/search/{id}` | ìƒˆë¡œìš´ íˆìŠ¤í† ë¦¬ ì—”íŠ¸ë¦¬ ìƒì„± ì•ˆí•¨ |
| ê³µìœ  ë§í¬ ìƒì„± | `/share/{id}` | ì½ê¸° ì „ìš© í¼ë¨¸ë§í¬ |
| ëŒ€í™” ì´ì–´ê°€ê¸° | `history.pushState` â†’ `/search/{new-id}` | ìƒˆë¡œìš´ íˆìŠ¤í† ë¦¬ ì—”íŠ¸ë¦¬ ìƒì„± |

**Key Insights**:
- `replaceState`: URLë§Œ ë³€ê²½, íˆìŠ¤í† ë¦¬ ì—”íŠ¸ë¦¬ ìƒì„± X (ì´ˆê¸° ID í• ë‹¹)
- `pushState`: ìƒˆ íˆìŠ¤í† ë¦¬ ì—”íŠ¸ë¦¬ ìƒì„± (ëŒ€í™” ì´ì–´ê°€ê¸°)
- SEO ê³ ë ¤ ì‹œ ì„œë²„ì—ì„œ `<a href>` ì œê³µ í•„ìš”

**ì°¸ê³  ë¬¸ì„œ**:
- [Pushstate and Replacestate: What You Need to Know](https://thatware.co/pushstate-vs-replacestate/)
- [History: pushState() method - MDN](https://developer.mozilla.org/en-US/docs/Web/API/History/pushState)

---

## 2. ê¸°ìˆ  êµ¬í˜„ íŒ¨í„´

### 2.1 ID ìƒì„±: Client vs Server

#### Server-Side ID ìƒì„± (ê¶Œì¥)

**ì¥ì **:
- ë°ì´í„°ë² ì´ìŠ¤ ë¬´ê²°ì„± ë³´ì¥
- ID ì¶©ëŒ ë°©ì§€
- ë³´ì•ˆì„± í–¥ìƒ (ì•…ì˜ì  ID ë³€ì¡° ë°©ì§€)
- ì„¸ì…˜ ê°„ ì¼ê´€ì„± ë³´ì¥

**êµ¬í˜„ ì˜ˆì‹œ (AI SDK)**:
```typescript
// Option 1: generateMessageId ì‚¬ìš©
return result.toUIMessageStreamResponse({
  generateMessageId: createIdGenerator({
    prefix: 'msg',
    size: 16,
  }),
  onFinish: ({ messages }) => {
    saveChat({ chatId, messages });
  },
});

// Option 2: createUIMessageStreamìœ¼ë¡œ ëª…ì‹œì  ì œì–´
const stream = createUIMessageStream({
  id: generateServerSideId(), // ì„œë²„ ìƒì„± ID
  // ...
});
```

**ì£¼ì˜ì‚¬í•­ (Next.js)**:
- `crypto.randomUUID()`ëŠ” Node.js ë‚´ì¥ ëª¨ë“ˆì´ë¯€ë¡œ í´ë¼ì´ì–¸íŠ¸ì—ì„œ ì‚¬ìš© ë¶ˆê°€
- ì„œë²„ ì»´í¬ë„ŒíŠ¸ì—ì„œë§Œ ì‚¬ìš© ê°€ëŠ¥
- í´ë¼ì´ì–¸íŠ¸ í•„ìš” ì‹œ `uuid` ë¼ì´ë¸ŒëŸ¬ë¦¬ ì‚¬ìš©

#### Client-Side ID ìƒì„±ì´ ì í•©í•œ ê²½ìš°

**ì‚¬ìš© ì‹œë‚˜ë¦¬ì˜¤**:
- ì˜¤í”„ë¼ì¸ ìš°ì„  ì•± (ëª¨ë°”ì¼ ì•± ë“±)
- ë©±ë“±ì„±(idempotency) ë³´ì¥ í•„ìš”
- ë„¤íŠ¸ì›Œí¬ ë¶ˆì•ˆì • í™˜ê²½ì—ì„œ ì¤‘ë³µ ìš”ì²­ ë°©ì§€

**ì˜ˆì‹œ**:
```typescript
// í´ë¼ì´ì–¸íŠ¸ì—ì„œ UUID ìƒì„± í›„ ì„œë²„ì— ì „ì†¡
import { v4 as uuidv4 } from 'uuid';

const chatId = uuidv4();
// ì„œë²„ì— chatIdì™€ í•¨ê»˜ ìš”ì²­
// ë„¤íŠ¸ì›Œí¬ ì‹¤íŒ¨ ì‹œ ë™ì¼í•œ chatIdë¡œ ì¬ì‹œë„ ê°€ëŠ¥
```

**ë³´ì•ˆ ê³ ë ¤ì‚¬í•­**:
- UUID ìŠ¤í‘¸í•‘ ê°€ëŠ¥ì„±
- ë°±ì—”ë“œì—ì„œ ë°˜ë“œì‹œ ì¤‘ë³µ ê²€ì¦ í•„ìš”
- ì¶©ëŒ í™•ë¥ ì€ ë§¤ìš° ë‚®ì§€ë§Œ ê²€ì¦ ë¡œì§ í•„ìˆ˜

**ì°¸ê³  ë¬¸ì„œ**:
- [Generating Id's Server vs Client side](https://stackoverflow.com/questions/59966008/generating-ids-server-vs-client-side)
- [Should I generate GUID/UUID on client or server?](https://softwareengineering.stackexchange.com/questions/367347/should-i-generate-guid-uuid-on-client-or-server)
- [How to generate a UUID in NextJs?](https://stackoverflow.com/questions/71851190/how-to-generate-a-uuid-in-nextjs)

---

### 2.2 ìµëª… â†’ ì¸ì¦ ì„¸ì…˜ ë§ˆì´ê·¸ë ˆì´ì…˜

#### íŒ¨í„´ 1: Session ID ìœ ì§€ + Event Migration (Google ADK)

```typescript
// 1. ìµëª… ì„¸ì…˜ì˜ ëª¨ë“  ì´ë²¤íŠ¸ ì¶”ì¶œ
const anonymousSession = await getSession(anonymousSessionId);
const events = extractEvents(anonymousSession);

// 2. ì¸ì¦ëœ ì‚¬ìš©ìë¡œ ìƒˆ ì„¸ì…˜ ìƒì„± (ë™ì¼í•œ ì„¸ì…˜ ID ìœ ì§€)
const authenticatedSession = await createSession({
  sessionId: anonymousSessionId, // ë™ì¼ ID ìœ ì§€
  userId: authenticatedUserId,
});

// 3. ì‹œìŠ¤í…œ ì´ë²¤íŠ¸ ì œì™¸í•˜ê³  ë§ˆì´ê·¸ë ˆì´ì…˜
const filteredEvents = events.filter(e => !e.isSystemEvent);
await injectEvents(authenticatedSession, filteredEvents);
```

**í•µì‹¬ ì›ì¹™**:
- ì´ë²¤íŠ¸ëŠ” ADKì˜ ê¸°ë³¸ ì •ë³´ ë‹¨ìœ„
- ì‹œìŠ¤í…œ ì´ë²¤íŠ¸ëŠ” ì¬ìƒì„±ë˜ë¯€ë¡œ ì œì™¸
- ì„¸ì…˜ ID ìœ ì§€ë¡œ URL ë³€ê²½ ì—†ì´ ì „í™˜

#### íŒ¨í„´ 2: Token-Based Session Linking (Crisp Chat SDK)

```typescript
// ìµëª… ì„¸ì…˜ ì‹œì‘
CrispSDK.chat.startAnonymousSession();

// ì‚¬ìš©ì ë¡œê·¸ì¸ ì‹œ
CrispSDK.auth.setUserToken(userToken);

// ìë™ìœ¼ë¡œ ìµëª… ì„¸ì…˜ â†’ ì¸ì¦ ì„¸ì…˜ ì „í™˜
// ë©”ì‹œì§€ íˆìŠ¤í† ë¦¬ ìœ ì§€
```

**íŠ¹ì§•**:
- í¬ë¡œìŠ¤ ë””ë°”ì´ìŠ¤ ì§€ì›
- ì¿ í‚¤ ì‚­ì œ ì‹œì—ë„ ì„¸ì…˜ ìœ ì§€ (í† í° ê¸°ë°˜)
- ë™ì¼ ì‚¬ìš©ìì˜ ëª¨ë“  ëŒ€í™”ë¥¼ í•˜ë‚˜ì˜ ì„¸ì…˜ìœ¼ë¡œ í†µí•©

#### íŒ¨í„´ 3: Session Transfer Code (ì„ì‹œ ì½”ë“œ)

```typescript
// Public ë””ë°”ì´ìŠ¤ì—ì„œ ì½”ë“œ ìƒì„±
const transferCode = await generateTransferCode(anonymousSessionId);
// í‘œì‹œ: "ABC123"

// Private ë””ë°”ì´ìŠ¤ì—ì„œ ì½”ë“œ ì…ë ¥
await migrateSessionWithCode(transferCode, authenticatedUserId);
```

**ì‚¬ìš© ì‚¬ë¡€**:
- ê³µìš© ë””ë°”ì´ìŠ¤ â†’ ê°œì¸ ë””ë°”ì´ìŠ¤ ì „í™˜
- ë³´ì•ˆì´ ì¤‘ìš”í•œ í™˜ê²½

#### íŒ¨í„´ 4: Session Invalidation & Reset (Infobip)

```typescript
// ë¡œê·¸ì•„ì›ƒ ì‹œ ì„¸ì…˜ ë¬´íš¨í™”
await invalidateSession(sessionId);

// ìœ„ì ¯ì—ì„œ ìµëª… ì„¸ì…˜ìœ¼ë¡œ ì¦‰ì‹œ ë¦¬ì…‹
// ë©”ì‹œì§€ íˆìŠ¤í† ë¦¬ëŠ” ë‹¤ìŒ ì¸ì¦ ë¡œê·¸ì¸ê¹Œì§€ ìˆ¨ê¹€
```

**ì°¸ê³  ë¬¸ì„œ**:
- [Mastering Google ADK DatabaseSessionService](https://dev.to/greyisheepai/mastering-google-adk-databasesessionservice-and-events-complete-guide-to-event-injection-and-pdm)
- [Session Continuity - Crisp Chat SDK](https://docs.crisp.chat/guides/chatbox-sdks/web-sdk/session-continuity/)
- [Live Chat: User types - Infobip](https://www.infobip.com/docs/live-chat/user-types)

---

## 3. ìŠ¤íŠ¸ë¦¬ë° + ì˜ì†í™” ë™ì‹œ ì²˜ë¦¬

### 3.1 ì•„í‚¤í…ì²˜ íŒ¨í„´: ë°ì´í„°ë² ì´ìŠ¤ Reactivity Layer

#### Convex Pattern (ê¶Œì¥)

**í•µì‹¬ ì•„ì´ë””ì–´**:
HTTP ìŠ¤íŠ¸ë¦¼ê³¼ ì„œë²„-AI ì—°ê²°ì„ ë¶„ë¦¬í•˜ê³ , ë°ì´í„°ë² ì´ìŠ¤ë¥¼ ì¤‘ê°„ ë°˜ì‘ì„± ê³„ì¸µìœ¼ë¡œ ì‚¬ìš©

```typescript
// 1. ì‚¬ìš©ì ë©”ì‹œì§€ ì¦‰ì‹œ ì €ì¥
const messageId = await ctx.runMutation(api.messages.create, {
  chatId,
  content: userMessage,
  role: 'user'
});

// 2. ë¹„ë™ê¸° ë°±ê·¸ë¼ìš´ë“œ ì•¡ì…˜ ìŠ¤ì¼€ì¤„ë§
await scheduler.runAfter(0, api.ai.processStream, {
  chatId,
  messageId
});

// 3. í´ë¼ì´ì–¸íŠ¸ëŠ” ì¦‰ì‹œ ì‘ë‹µ ë°›ê³  ì—°ê²° ì¢…ë£Œ ê°€ëŠ¥
return { success: true, messageId };
```

**ë°±ê·¸ë¼ìš´ë“œ ì²˜ë¦¬**:
```typescript
// actions/ai.ts
export const processStream = internalAction(async (ctx, args) => {
  const stream = await openai.chat.completions.create({
    model: 'gpt-4',
    messages: [...],
    stream: true,
  });

  let body = '';
  for await (const part of stream) {
    const token = part.choices[0].delta.content;
    body += token;

    // ë°ì´í„°ë² ì´ìŠ¤ì— ì ì§„ì ìœ¼ë¡œ ì—…ë°ì´íŠ¸
    await ctx.runMutation(api.messages.update, {
      messageId: args.messageId,
      content: body,
    });
  }
});
```

**í´ë¼ì´ì–¸íŠ¸ êµ¬ë…**:
```typescript
// ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸ ìë™ ìˆ˜ì‹ 
const messages = useQuery(api.messages.list, { chatId });

// ë¸Œë¼ìš°ì € ìƒˆë¡œê³ ì¹¨ ì‹œì—ë„ ìµœì‹  ìƒíƒœ ìë™ ë³µì›
```

**ì¥ì **:
- í´ë¼ì´ì–¸íŠ¸ ì—°ê²° ì¢…ë£Œ í›„ì—ë„ AI ì‘ë‹µ ì§€ì† ì²˜ë¦¬
- ìë™ ìƒíƒœ ë³µì› (ìƒˆë¡œê³ ì¹¨, íƒ­ ì „í™˜)
- ë©€í‹°í”Œë ˆì´ì–´ ì—…ë°ì´íŠ¸ ì§€ì› (ì—¬ëŸ¬ ì‚¬ìš©ìê°€ ë™ì‹œì— ê°™ì€ ëŒ€í™” ì¡°íšŒ)
- í‰ê·  ë ˆì´í„´ì‹œ: ì¿¼ë¦¬ ~17ms, ì—…ë°ì´íŠ¸ ~7ms

**ì°¸ê³  ë¬¸ì„œ**:
- [GPT Streaming with Persistent Reactivity](https://stack.convex.dev/gpt-streaming-with-persistent-reactivity)

---

### 3.2 ì„ íƒì  ì˜ì†í™”: Sentence Boundary Batching

#### Convex Persistent Text Streaming Component

**ë¬¸ì œ**:
ëª¨ë“  í† í°ë§ˆë‹¤ DBì— ì“°ë©´ ë¶ˆí•„ìš”í•œ ë¶€í•˜ ë°œìƒ

**í•´ê²°ì±…**:
ë¬¸ì¥ ë‹¨ìœ„ë¡œ ë°°ì¹˜ ì—…ë°ì´íŠ¸

```typescript
export const stream = httpAction(async (ctx, request) => {
  const { streamId } = await request.json();

  // HTTP ìŠ¤íŠ¸ë¦¼ì€ í† í°ë§ˆë‹¤ ì¦‰ì‹œ ì „ì†¡
  const stream = createAIStream();

  // DB ì—…ë°ì´íŠ¸ëŠ” ë¬¸ì¥ ê²½ê³„ì—ì„œë§Œ
  let buffer = '';
  let lastUpdate = Date.now();

  for await (const token of stream) {
    buffer += token;

    // HTTPë¡œ ì¦‰ì‹œ ì „ì†¡
    response.write(token);

    // ë¬¸ì¥ ì¢…ë£Œ ë˜ëŠ” ì‹œê°„ ê²½ê³¼ ì‹œ DB ì—…ë°ì´íŠ¸
    if (isSentenceEnd(token) || Date.now() - lastUpdate > 200) {
      await ctx.runMutation(api.streams.update, {
        streamId,
        content: buffer,
      });
      lastUpdate = Date.now();
    }
  }

  return response;
});
```

**ë°°ì¹˜ ì „ëµ**:
1. **ë¬¸ì¥ ê²½ê³„**: `.` `!` `?` ë“± ê°ì§€
2. **ì‹œê°„ ê¸°ë°˜**: 200msë§ˆë‹¤ (í† í° ëˆ„ì )
3. **ë²„í¼ í¬ê¸°**: ì¼ì • í¬ê¸° ì´ìƒ ì‹œ

**íš¨ê³¼**:
- DB ì“°ê¸° ìµœëŒ€ 80-90% ê°ì†Œ
- í´ë¼ì´ì–¸íŠ¸ëŠ” ì—¬ì „íˆ ì‹¤ì‹œê°„ ìŠ¤íŠ¸ë¦¬ë° ê²½í—˜
- ì—°ê²° ëŠê¹€ ì‹œì—ë„ ë¬¸ì¥ ë‹¨ìœ„ë¡œ ë³µì› ê°€ëŠ¥

**ì°¸ê³  ë¬¸ì„œ**:
- [Persistent Text Streaming - Convex](https://www.convex.dev/components/persistent-text-streaming)

---

### 3.3 Stream Consumption Pattern

#### AI SDKì˜ consumeStream()

**ë¬¸ì œ**:
í´ë¼ì´ì–¸íŠ¸ ì—°ê²° ëŠê¹€ ì‹œ ìŠ¤íŠ¸ë¦¼ ì²˜ë¦¬ ì¤‘ë‹¨

**í•´ê²°ì±…**:
```typescript
export async function POST(request: Request) {
  const result = await streamText({
    model: openai('gpt-4'),
    messages: [...],
  });

  // ë°±ê·¸ë¼ìš´ë“œì—ì„œ ìŠ¤íŠ¸ë¦¼ ì†Œë¹„ (í´ë¼ì´ì–¸íŠ¸ ì—°ê²°ê³¼ ë¬´ê´€)
  result.consumeStream(); // await í•˜ì§€ ì•ŠìŒ!

  // í´ë¼ì´ì–¸íŠ¸ë¡œ ìŠ¤íŠ¸ë¦¬ë° ì‘ë‹µ
  return result.toUIMessageStreamResponse({
    onFinish: async ({ messages }) => {
      // ìŠ¤íŠ¸ë¦¼ ì™„ë£Œ í›„ ì˜ì†í™”
      await saveChat({ chatId, messages });
    },
  });
}
```

**ì‘ë™ ì›ë¦¬**:
1. `consumeStream()`ì€ ë°±í”„ë ˆì…” ì—†ì´ ìŠ¤íŠ¸ë¦¼ ì†Œë¹„
2. í´ë¼ì´ì–¸íŠ¸ ì—°ê²° ëŠê²¨ë„ ë°±ê·¸ë¼ìš´ë“œì—ì„œ ê³„ì† ì§„í–‰
3. `onFinish` ì½œë°±ì—ì„œ ì™„ì „í•œ ê²°ê³¼ ì˜ì†í™”

**ì£¼ì˜ì‚¬í•­**:
- `await` ì—†ì´ í˜¸ì¶œ (ë¹„ë™ê¸° ë°±ê·¸ë¼ìš´ë“œ ì‹¤í–‰)
- ì„œë²„ë¦¬ìŠ¤ í™˜ê²½ì—ì„œëŠ” íƒ€ì„ì•„ì›ƒ ê³ ë ¤ í•„ìš”

**ì°¸ê³  ë¬¸ì„œ**:
- [AI SDK UI: Chatbot Message Persistence](https://ai-sdk.dev/docs/ai-sdk-ui/chatbot-message-persistence)

---

### 3.4 Server-Sent Events (SSE) êµ¬í˜„

#### ê¸°ë³¸ êµ¬ì¡°

```typescript
// Server
app.get('/api/stream/:chatId', (req, res) => {
  res.setHeader('Content-Type', 'text/event-stream');
  res.setHeader('Cache-Control', 'no-cache');
  res.setHeader('Connection', 'keep-alive');

  const chatId = req.params.chatId;
  const lastEventId = req.headers['last-event-id'];

  // ì¬ì—°ê²° ì‹œ ëˆ„ë½ëœ ì´ë²¤íŠ¸ ì „ì†¡
  if (lastEventId) {
    const missedEvents = await getMissedEvents(chatId, lastEventId);
    missedEvents.forEach(event => {
      res.write(`id: ${event.id}\n`);
      res.write(`data: ${JSON.stringify(event.data)}\n\n`);
    });
  }

  // ì‹¤ì‹œê°„ ìŠ¤íŠ¸ë¦¼ ì—°ê²°
  const stream = subscribeToChat(chatId);
  stream.on('data', (chunk) => {
    res.write(`id: ${chunk.id}\n`);
    res.write(`data: ${JSON.stringify(chunk)}\n\n`);

    // DB ì €ì¥ (ë¹„ë™ê¸°)
    saveChunk(chatId, chunk);
  });
});
```

```typescript
// Client
const eventSource = new EventSource(`/api/stream/${chatId}`);

eventSource.onmessage = (event) => {
  const data = JSON.parse(event.data);
  updateUI(data);
};

eventSource.onerror = () => {
  // ìë™ ì¬ì—°ê²° (Last-Event-ID í—¤ë” ìë™ ì „ì†¡)
  console.log('Reconnecting...');
};
```

#### Shopify ì‚¬ë¡€: Kafka + SSE

```go
// Golang SSE ì„œë²„
func (s *SSEServer) HandleStream(w http.ResponseWriter, r *http.Request) {
    // Kafka í† í”½ êµ¬ë…
    consumer := s.kafka.Subscribe(topicName)

    // SSE í—¤ë” ì„¤ì •
    w.Header().Set("Content-Type", "text/event-stream")

    // ë°ì´í„° í‘¸ì‹œ
    for msg := range consumer.Messages() {
        fmt.Fprintf(w, "data: %s\n\n", msg.Value)
        w.(http.Flusher).Flush()

        // DB ì €ì¥
        s.db.Save(msg)
    }
}
```

**ì¥ì **:
- í´ë§ ì œê±° â†’ ì§€ì—° ì‹œê°„ ê°ì†Œ
- HTTP/2ì—ì„œ 100ê°œ ë™ì‹œ ìŠ¤íŠ¸ë¦¼ ì§€ì›
- ìë™ ì¬ì—°ê²° + Last-Event-ID ê¸°ë°˜ ì´ë²¤íŠ¸ ë³µì›

**ì œí•œì‚¬í•­**:
- HTTP/1.1ì—ì„œëŠ” ë„ë©”ì¸ë‹¹ 6ê°œ ì—°ê²° ì œí•œ
- ë‹¨ë°©í–¥ í†µì‹  (ì–‘ë°©í–¥ í•„ìš” ì‹œ WebSocket)

**ì°¸ê³  ë¬¸ì„œ**:
- [Using Server Sent Events to Simplify Real-time Streaming at Scale](https://shopify.engineering/server-sent-events-data-streaming)
- [Real-Time Data Streaming with Server-Sent Events (SSE)](https://dev.to/serifcolakel/real-time-data-streaming-with-server-sent-events-sse-1gb2)

---

### 3.5 ìŠ¤íŠ¸ë¦¬ë° íƒ€ì´ë° ë³„ ì €ì¥ ì „ëµ ë¹„êµ

| ì „ëµ | ì €ì¥ ì‹œì  | ì¥ì  | ë‹¨ì  | ì í•© ì‚¬ë¡€ |
|-----|---------|------|------|----------|
| **Token-by-Token** | ëª¨ë“  í† í°ë§ˆë‹¤ | ìµœëŒ€ ì •ë°€ë„ | DB ë¶€í•˜ ê·¹ëŒ€ | ì‹¤ì‹œê°„ í˜‘ì—… ì—ë””í„° |
| **Sentence Boundary** | ë¬¸ì¥ ì¢…ë£Œ ì‹œ | ì˜ë¯¸ ë‹¨ìœ„ ì €ì¥, ë¶€í•˜ ê°ì†Œ | êµ¬í˜„ ë³µì¡ë„ ì¦ê°€ | ì¼ë°˜ AI ì±—ë´‡ |
| **Time-Based Batching** | 200msë§ˆë‹¤ | ì˜ˆì¸¡ ê°€ëŠ¥í•œ ë¶€í•˜ | ì„ì˜ ì§€ì ì—ì„œ ëŠê¹€ | ë¡œê·¸ ìŠ¤íŠ¸ë¦¬ë° |
| **onFinish Only** | ìŠ¤íŠ¸ë¦¼ ì™„ë£Œ í›„ | ìµœì†Œ ë¶€í•˜ | ì¤‘ê°„ ìƒíƒœ ì—†ìŒ | ë‹¨ì¼ ì‚¬ìš©ì ì±—ë´‡ |
| **Hybrid (ê¶Œì¥)** | ì‹œê°„ + ë¬¸ì¥ ê²½ê³„ | ê· í˜• ì¡íŒ ì ‘ê·¼ | êµ¬í˜„ ë³µì¡ | ëŒ€ë¶€ë¶„ì˜ í”„ë¡œë•ì…˜ |

**ê¶Œì¥ Hybrid êµ¬í˜„**:
```typescript
let buffer = '';
let lastSave = Date.now();
const SAVE_INTERVAL = 200; // ms
const MIN_BUFFER_SIZE = 50; // chars

for await (const token of stream) {
  buffer += token;

  const shouldSave =
    isSentenceEnd(token) ||
    (Date.now() - lastSave > SAVE_INTERVAL && buffer.length > MIN_BUFFER_SIZE);

  if (shouldSave) {
    await saveToDatabase(buffer);
    lastSave = Date.now();
  }
}
```

---

## 4. Best Practices

### 4.1 URL ë¼ìš°íŒ… ì „ëµ

#### 1. ì´ˆê¸° ê²€ìƒ‰ ì‹œì‘

```typescript
// ì‚¬ìš©ìê°€ /search ì§„ì…
router.push('/search'); // ë˜ëŠ” ì‚¬ìš©ìê°€ ì§ì ‘ ì§„ì…

// ì„œë²„/í´ë¼ì´ì–¸íŠ¸ì—ì„œ ID ìƒì„±
const chatId = await generateChatId(); // ì„œë²„ ê¶Œì¥

// URL ì—…ë°ì´íŠ¸ (íˆìŠ¤í† ë¦¬ ì—”íŠ¸ë¦¬ ìƒì„± ì•ˆí•¨)
window.history.replaceState(
  { chatId },
  '',
  `/search/${chatId}`
);
```

**ì´ìœ **:
- ë’¤ë¡œê°€ê¸° ì‹œ `/search`ë¡œ ëŒì•„ê°€ì§€ ì•ŠìŒ
- ë¶ë§ˆí¬/ê³µìœ  ê°€ëŠ¥í•œ URL ì¦‰ì‹œ ì œê³µ

#### 2. ìƒˆë¡œìš´ ì§ˆë¬¸ (ëŒ€í™” ì´ì–´ê°€ê¸°)

```typescript
// ê¸°ì¡´ ëŒ€í™”ì—ì„œ ìƒˆ ì§ˆë¬¸
const newChatId = await forkConversation(currentChatId);

// ìƒˆ íˆìŠ¤í† ë¦¬ ì—”íŠ¸ë¦¬ ìƒì„±
window.history.pushState(
  { chatId: newChatId },
  '',
  `/search/${newChatId}`
);
```

**ì´ìœ **:
- ë’¤ë¡œê°€ê¸°ë¡œ ì´ì „ ëŒ€í™” ë³µì› ê°€ëŠ¥
- ëŒ€í™” ë¶„ê¸°(fork) ì§€ì›

#### 3. ê³µìœ  ë§í¬ ì „ìš© ë¼ìš°íŠ¸

```typescript
// ì½ê¸° ì „ìš© ê³µìœ  í˜ì´ì§€
/share/{chatId}

// ë˜ëŠ” ì¿¼ë¦¬ íŒŒë¼ë¯¸í„°ë¡œ êµ¬ë¶„
/search/{chatId}?shared=true
```

**SEO ê³ ë ¤ì‚¬í•­**:
```html
<!-- ì„œë²„ ë Œë”ë§ ì‹œ ë©”íƒ€ íƒœê·¸ ì£¼ì… -->
<meta property="og:title" content="AI ê²€ìƒ‰ ê²°ê³¼: {query}" />
<meta property="og:description" content="{summary}" />
<meta property="og:image" content="{thumbnail}" />
<meta property="og:url" content="https://example.com/share/{id}" />
```

---

### 4.2 ë°ì´í„°ë² ì´ìŠ¤ ìŠ¤í‚¤ë§ˆ ì„¤ê³„

#### Chat í…Œì´ë¸”

```sql
CREATE TABLE chats (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  title TEXT, -- ì²« ì§ˆë¬¸ ë˜ëŠ” ìš”ì•½
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  is_shared BOOLEAN DEFAULT FALSE,
  share_token UUID UNIQUE, -- ê³µìœ  ë§í¬ìš© ë³„ë„ í† í°
  metadata JSONB -- ì¶”ê°€ ë©”íƒ€ë°ì´í„°
);

CREATE INDEX idx_chats_user_id ON chats(user_id);
CREATE INDEX idx_chats_share_token ON chats(share_token) WHERE is_shared = TRUE;
```

#### Messages í…Œì´ë¸”

```sql
CREATE TABLE messages (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  chat_id UUID REFERENCES chats(id) ON DELETE CASCADE,
  role TEXT NOT NULL CHECK (role IN ('user', 'assistant', 'system')),
  content TEXT NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW(),

  -- ìŠ¤íŠ¸ë¦¬ë° ìƒíƒœ ì¶”ì 
  is_streaming BOOLEAN DEFAULT FALSE,
  stream_completed_at TIMESTAMPTZ,

  -- ë„êµ¬ í˜¸ì¶œ ë° ë©”íƒ€ë°ì´í„°
  tool_calls JSONB,
  metadata JSONB,

  -- ìˆœì„œ ë³´ì¥
  sequence INTEGER NOT NULL
);

CREATE INDEX idx_messages_chat_id ON messages(chat_id, sequence);
CREATE INDEX idx_messages_streaming ON messages(chat_id) WHERE is_streaming = TRUE;
```

#### Citations í…Œì´ë¸” (Perplexity ìŠ¤íƒ€ì¼)

```sql
CREATE TABLE citations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  message_id UUID REFERENCES messages(id) ON DELETE CASCADE,
  url TEXT NOT NULL,
  title TEXT,
  snippet TEXT,
  position INTEGER, -- ë³¸ë¬¸ ë‚´ ìœ„ì¹˜
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_citations_message_id ON citations(message_id);
```

---

### 4.3 ìƒíƒœ ê´€ë¦¬ íŒ¨í„´

#### React Query + Optimistic Updates

```typescript
// hooks/useChat.ts
export function useChat(chatId: string) {
  const queryClient = useQueryClient();

  // ë©”ì‹œì§€ ì¡°íšŒ
  const { data: messages } = useQuery({
    queryKey: ['chat', chatId, 'messages'],
    queryFn: () => fetchMessages(chatId),
    refetchInterval: (data) => {
      // ìŠ¤íŠ¸ë¦¬ë° ì¤‘ì¸ ë©”ì‹œì§€ê°€ ìˆìœ¼ë©´ 1ì´ˆë§ˆë‹¤ í´ë§
      const hasStreaming = data?.some(m => m.isStreaming);
      return hasStreaming ? 1000 : false;
    },
  });

  // ë©”ì‹œì§€ ì „ì†¡
  const sendMessage = useMutation({
    mutationFn: (content: string) =>
      sendChatMessage(chatId, content),

    // Optimistic update
    onMutate: async (content) => {
      await queryClient.cancelQueries(['chat', chatId, 'messages']);

      const previous = queryClient.getQueryData(['chat', chatId, 'messages']);

      queryClient.setQueryData(['chat', chatId, 'messages'], (old) => [
        ...old,
        {
          id: 'temp-' + Date.now(),
          role: 'user',
          content,
          createdAt: new Date(),
        },
      ]);

      return { previous };
    },

    onError: (err, variables, context) => {
      queryClient.setQueryData(
        ['chat', chatId, 'messages'],
        context.previous
      );
    },

    onSettled: () => {
      queryClient.invalidateQueries(['chat', chatId, 'messages']);
    },
  });

  return { messages, sendMessage };
}
```

#### SSE ê¸°ë°˜ ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸

```typescript
// hooks/useStreamingMessage.ts
export function useStreamingMessage(chatId: string, messageId: string) {
  const [content, setContent] = useState('');
  const [isComplete, setIsComplete] = useState(false);

  useEffect(() => {
    const eventSource = new EventSource(
      `/api/chat/${chatId}/messages/${messageId}/stream`
    );

    eventSource.onmessage = (event) => {
      const data = JSON.parse(event.data);

      if (data.type === 'token') {
        setContent(prev => prev + data.content);
      } else if (data.type === 'done') {
        setIsComplete(true);
        eventSource.close();
      }
    };

    eventSource.onerror = () => {
      // ì¬ì—°ê²°ì€ EventSourceê°€ ìë™ ì²˜ë¦¬
      console.log('Connection lost, reconnecting...');
    };

    return () => eventSource.close();
  }, [chatId, messageId]);

  return { content, isComplete };
}
```

---

### 4.4 ì—ëŸ¬ ì²˜ë¦¬ ë° ë³µì›

#### ìŠ¤íŠ¸ë¦¼ ì¤‘ë‹¨ ì²˜ë¦¬

```typescript
// Server
export async function POST(request: Request) {
  const { chatId, messageId } = await request.json();

  try {
    const stream = await streamAI(messageId);

    // í´ë¼ì´ì–¸íŠ¸ ì—°ê²° ëŠê¹€ ê°ì§€
    request.signal.addEventListener('abort', async () => {
      console.log('Client disconnected, continuing in background');

      // ë°±ê·¸ë¼ìš´ë“œì—ì„œ ê³„ì† ì²˜ë¦¬
      await consumeStreamToDatabase(stream, messageId);
    });

    return new Response(stream, {
      headers: {
        'Content-Type': 'text/event-stream',
        'Cache-Control': 'no-cache',
      },
    });
  } catch (error) {
    // ì—ëŸ¬ ì‹œ ë©”ì‹œì§€ ìƒíƒœ ì—…ë°ì´íŠ¸
    await updateMessageStatus(messageId, 'error', error.message);
    throw error;
  }
}
```

#### ì¬ì—°ê²° ë° ìƒíƒœ ë³µì›

```typescript
// Client
class ResilientSSEClient {
  private eventSource: EventSource | null = null;
  private reconnectAttempts = 0;
  private maxReconnectAttempts = 5;

  connect(url: string, onMessage: (data: any) => void) {
    this.eventSource = new EventSource(url);

    this.eventSource.onmessage = (event) => {
      this.reconnectAttempts = 0; // ì„±ê³µ ì‹œ ë¦¬ì…‹
      onMessage(JSON.parse(event.data));
    };

    this.eventSource.onerror = () => {
      this.eventSource?.close();

      if (this.reconnectAttempts < this.maxReconnectAttempts) {
        const delay = Math.min(1000 * Math.pow(2, this.reconnectAttempts), 10000);
        this.reconnectAttempts++;

        setTimeout(() => {
          console.log(`Reconnecting (attempt ${this.reconnectAttempts})...`);
          this.connect(url, onMessage);
        }, delay);
      } else {
        // ìµœëŒ€ ì¬ì‹œë„ ì´ˆê³¼ ì‹œ DBì—ì„œ ì§ì ‘ ì¡°íšŒ
        this.fallbackToPolling();
      }
    };
  }

  private async fallbackToPolling() {
    console.log('Falling back to polling');
    // SSE ì‹¤íŒ¨ ì‹œ HTTP í´ë§ìœ¼ë¡œ ì „í™˜
    const interval = setInterval(async () => {
      const data = await fetch('/api/messages/' + messageId);
      if (data.isComplete) {
        clearInterval(interval);
      }
      updateUI(data);
    }, 2000);
  }
}
```

---

### 4.5 ì„±ëŠ¥ ìµœì í™”

#### 1. ë©”ì‹œì§€ í˜ì´ì§€ë„¤ì´ì…˜

```typescript
// ë¬´í•œ ìŠ¤í¬ë¡¤
export function useChatMessages(chatId: string) {
  return useInfiniteQuery({
    queryKey: ['chat', chatId, 'messages'],
    queryFn: ({ pageParam = 0 }) =>
      fetchMessages(chatId, { offset: pageParam, limit: 50 }),
    getNextPageParam: (lastPage, pages) =>
      lastPage.hasMore ? pages.length * 50 : undefined,
  });
}
```

#### 2. ì¸ë±ì‹± ì „ëµ

```sql
-- ìµœì‹  ë©”ì‹œì§€ ì¡°íšŒ ìµœì í™”
CREATE INDEX idx_messages_chat_latest
ON messages(chat_id, created_at DESC);

-- ì „ë¬¸ ê²€ìƒ‰ (PostgreSQL)
CREATE INDEX idx_messages_content_fts
ON messages USING GIN(to_tsvector('english', content));

-- íŒŒí‹°ì…”ë‹ (ëŒ€ëŸ‰ ë°ì´í„°)
CREATE TABLE messages_partitioned (
  LIKE messages INCLUDING ALL
) PARTITION BY RANGE (created_at);

CREATE TABLE messages_2025_01 PARTITION OF messages_partitioned
FOR VALUES FROM ('2025-01-01') TO ('2025-02-01');
```

#### 3. ìºì‹± ì „ëµ

```typescript
// Redis ìºì‹±
export async function getChatMessages(chatId: string) {
  const cacheKey = `chat:${chatId}:messages`;

  // 1. Redis í™•ì¸
  const cached = await redis.get(cacheKey);
  if (cached) return JSON.parse(cached);

  // 2. DB ì¡°íšŒ
  const messages = await db.query(
    'SELECT * FROM messages WHERE chat_id = $1 ORDER BY sequence',
    [chatId]
  );

  // 3. Redisì— ìºì‹± (TTL 5ë¶„)
  await redis.setex(cacheKey, 300, JSON.stringify(messages));

  return messages;
}

// ë©”ì‹œì§€ ì¶”ê°€ ì‹œ ìºì‹œ ë¬´íš¨í™”
export async function addMessage(chatId: string, message: Message) {
  await db.insertMessage(message);
  await redis.del(`chat:${chatId}:messages`);
}
```

---

### 4.6 SEO ë° ê³µìœ  ìµœì í™”

#### Open Graph ë©”íƒ€ íƒœê·¸ ìƒì„±

```typescript
// app/share/[id]/page.tsx (Next.js App Router)
export async function generateMetadata({ params }: Props): Promise<Metadata> {
  const chat = await getSharedChat(params.id);

  const firstMessage = chat.messages.find(m => m.role === 'user');
  const summary = generateSummary(chat.messages);

  return {
    title: `AI ê²€ìƒ‰: ${firstMessage?.content.slice(0, 60)}...`,
    description: summary,
    openGraph: {
      title: firstMessage?.content,
      description: summary,
      url: `https://example.com/share/${params.id}`,
      siteName: 'AI Search',
      images: [
        {
          url: await generateOGImage(chat), // ë™ì  ì´ë¯¸ì§€ ìƒì„±
          width: 1200,
          height: 630,
        },
      ],
      type: 'website',
    },
    twitter: {
      card: 'summary_large_image',
      title: firstMessage?.content,
      description: summary,
    },
  };
}
```

#### ë™ì  OG ì´ë¯¸ì§€ ìƒì„± (Vercel OG)

```typescript
// app/api/og/route.tsx
import { ImageResponse } from 'next/og';

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const chatId = searchParams.get('chatId');

  const chat = await getChat(chatId);
  const firstQ = chat.messages[0]?.content;
  const firstA = chat.messages[1]?.content.slice(0, 200);

  return new ImageResponse(
    (
      <div
        style={{
          display: 'flex',
          flexDirection: 'column',
          width: '100%',
          height: '100%',
          backgroundColor: '#0f172a',
          padding: '60px',
        }}
      >
        <h1 style={{ color: '#fff', fontSize: 48 }}>
          {firstQ}
        </h1>
        <p style={{ color: '#94a3b8', fontSize: 32, marginTop: 20 }}>
          {firstA}...
        </p>
      </div>
    ),
    {
      width: 1200,
      height: 630,
    }
  );
}
```

#### robots.txt ì„¤ì •

```txt
# robots.txt
User-agent: *
Allow: /
Allow: /share/*

User-agent: GPTBot
Allow: /

User-agent: PerplexityBot
Allow: /

User-agent: ClaudeBot
Allow: /

Sitemap: https://example.com/sitemap.xml
```

#### Structured Data (JSON-LD)

```typescript
export function generateChatStructuredData(chat: Chat) {
  return {
    '@context': 'https://schema.org',
    '@type': 'QAPage',
    mainEntity: {
      '@type': 'Question',
      name: chat.messages[0]?.content,
      text: chat.messages[0]?.content,
      answerCount: 1,
      acceptedAnswer: {
        '@type': 'Answer',
        text: chat.messages[1]?.content,
        author: {
          '@type': 'Organization',
          name: 'AI Search Assistant',
        },
      },
    },
  };
}
```

---

## 5. êµ¬í˜„ ê¶Œì¥ì‚¬í•­

### 5.1 ë‹¨ê³„ë³„ êµ¬í˜„ ë¡œë“œë§µ

#### Phase 1: ê¸°ë³¸ ì˜ì†í™” (MVP)

**ëª©í‘œ**: ê²€ìƒ‰ ê²°ê³¼ ì €ì¥ ë° URL ê³µìœ 

```typescript
// 1. ì„œë²„ì—ì„œ Chat ID ìƒì„±
POST /api/chats
Response: { chatId: "uuid" }

// 2. ë©”ì‹œì§€ ì „ì†¡ ë° ì €ì¥
POST /api/chats/{chatId}/messages
Body: { content: "ì§ˆë¬¸" }
Response: { messageId: "uuid" }

// 3. URL ì—…ë°ì´íŠ¸
window.history.replaceState(null, '', `/search/${chatId}`);

// 4. ê³µìœ  ë§í¬ ìƒì„±
POST /api/chats/{chatId}/share
Response: { shareUrl: "/share/{shareToken}" }
```

**í•„ìš” ì»´í¬ë„ŒíŠ¸**:
- Chat ë° Message í…Œì´ë¸”
- ê¸°ë³¸ CRUD API
- URL ë¼ìš°íŒ…

---

#### Phase 2: ìŠ¤íŠ¸ë¦¬ë° ì§€ì›

**ëª©í‘œ**: ì‹¤ì‹œê°„ ì‘ë‹µ + ì˜ì†í™”

```typescript
// SSE ì—”ë“œí¬ì¸íŠ¸
GET /api/chats/{chatId}/messages/{messageId}/stream

// í´ë¼ì´ì–¸íŠ¸
const eventSource = new EventSource(url);
eventSource.onmessage = (e) => {
  updateUI(JSON.parse(e.data));
};

// ì„œë²„ (ë°±ê·¸ë¼ìš´ë“œ ì €ì¥)
await scheduleBackgroundSave(messageId, stream);
```

**í•„ìš” ì»´í¬ë„ŒíŠ¸**:
- SSE ì—”ë“œí¬ì¸íŠ¸
- ë°±ê·¸ë¼ìš´ë“œ ì‘ì—… í
- ìŠ¤íŠ¸ë¦¬ë° ìƒíƒœ ì¶”ì 

---

#### Phase 3: ì„¸ì…˜ ê´€ë¦¬

**ëª©í‘œ**: ìµëª… â†’ ì¸ì¦ ì „í™˜

```typescript
// ìµëª… ì„¸ì…˜
const anonymousId = uuidv4();
localStorage.setItem('anonymousSessionId', anonymousId);

// ë¡œê·¸ì¸ ì‹œ ë§ˆì´ê·¸ë ˆì´ì…˜
POST /api/sessions/migrate
Body: {
  anonymousSessionId: localStorage.getItem('anonymousSessionId'),
  userId: currentUser.id
}

// ì„œë²„ì—ì„œ ì„¸ì…˜ ë³‘í•©
await migrateAnonymousSessions(anonymousId, userId);
```

**í•„ìš” ì»´í¬ë„ŒíŠ¸**:
- ìµëª… ì„¸ì…˜ ì¶”ì 
- ì„¸ì…˜ ë§ˆì´ê·¸ë ˆì´ì…˜ API
- ì‚¬ìš©ì ì—°ê²° ë¡œì§

---

#### Phase 4: ê³ ê¸‰ ê¸°ëŠ¥

**ëª©í‘œ**: ë©€í‹°í”Œë ˆì´ì–´, ì˜¤í”„ë¼ì¸ ì§€ì›, ê³ ê¸‰ ê³µìœ 

```typescript
// WebSocket ì‹¤ì‹œê°„ ë™ê¸°í™”
const ws = new WebSocket(`/api/chats/${chatId}/realtime`);
ws.onmessage = (e) => {
  const { type, data } = JSON.parse(e.data);
  if (type === 'message_update') {
    updateMessage(data);
  }
};

// ì˜¤í”„ë¼ì¸ ì§€ì› (Service Worker)
self.addEventListener('fetch', (event) => {
  event.respondWith(
    caches.match(event.request).then((response) => {
      return response || fetch(event.request);
    })
  );
});

// ê³µìœ  ê¶Œí•œ ê´€ë¦¬
POST /api/chats/{chatId}/permissions
Body: {
  users: [{ email: "user@example.com", role: "viewer" }]
}
```

**í•„ìš” ì»´í¬ë„ŒíŠ¸**:
- WebSocket ì„œë²„
- Service Worker
- ê¶Œí•œ ê´€ë¦¬ ì‹œìŠ¤í…œ
- ì˜¤í”„ë¼ì¸ í

---

### 5.2 Careerly v2 ì ìš© ë°©ì•ˆ

#### í˜„ì¬ êµ¬ì¡° ë¶„ì„

```typescript
// í˜„ì¬ API í´ë¼ì´ì–¸íŠ¸ êµ¬ì¡°
lib/api/
â”œâ”€â”€ clients/          # REST, GraphQL, SSE í´ë¼ì´ì–¸íŠ¸
â”œâ”€â”€ services/         # auth, search, user, discover
â”œâ”€â”€ hooks/
â”‚   â”œâ”€â”€ queries/
â”‚   â””â”€â”€ mutations/
â”œâ”€â”€ auth/             # í† í° ê´€ë¦¬
â”œâ”€â”€ types/
â””â”€â”€ interceptors/     # ì—ëŸ¬ ì²˜ë¦¬
```

#### ê¶Œì¥ í™•ì¥ êµ¬ì¡°

```typescript
lib/api/
â”œâ”€â”€ clients/
â”‚   â”œâ”€â”€ rest.ts
â”‚   â”œâ”€â”€ sse.ts         # âœ… ê¸°ì¡´
â”‚   â””â”€â”€ websocket.ts   # ğŸ†• ì‹¤ì‹œê°„ ë™ê¸°í™”ìš© (ì„ íƒ)
â”œâ”€â”€ services/
â”‚   â”œâ”€â”€ search.ts      # âœ… ê¸°ì¡´
â”‚   â””â”€â”€ chat.ts        # ğŸ†• ëŒ€í™” ì˜ì†í™” ì„œë¹„ìŠ¤
â”œâ”€â”€ hooks/
â”‚   â”œâ”€â”€ queries/
â”‚   â”‚   â”œâ”€â”€ useSearch.ts          # âœ… ê¸°ì¡´
â”‚   â”‚   â”œâ”€â”€ useChatMessages.ts    # ğŸ†•
â”‚   â”‚   â””â”€â”€ useSharedChat.ts      # ğŸ†•
â”‚   â””â”€â”€ mutations/
â”‚       â”œâ”€â”€ useLogin.ts            # âœ… ê¸°ì¡´
â”‚       â”œâ”€â”€ useSendMessage.ts     # ğŸ†•
â”‚       â””â”€â”€ useShareChat.ts       # ğŸ†•
â””â”€â”€ types/
    â”œâ”€â”€ search.ts      # âœ… ê¸°ì¡´
    â””â”€â”€ chat.ts        # ğŸ†• Chat, Message, Citation íƒ€ì…
```

#### êµ¬í˜„ ì˜ˆì‹œ

**1. Chat ì„œë¹„ìŠ¤ ì¶”ê°€**

```typescript
// lib/api/services/chat.ts
import { apiClient } from '../clients/rest';
import type { Chat, Message, CreateChatRequest } from '../types/chat';

export const chatService = {
  // Chat CRUD
  async createChat(data: CreateChatRequest): Promise<Chat> {
    return apiClient.post('/chats', data);
  },

  async getChat(chatId: string): Promise<Chat> {
    return apiClient.get(`/chats/${chatId}`);
  },

  async getChatMessages(chatId: string, offset = 0, limit = 50): Promise<Message[]> {
    return apiClient.get(`/chats/${chatId}/messages`, {
      params: { offset, limit },
    });
  },

  // ë©”ì‹œì§€ ì „ì†¡
  async sendMessage(chatId: string, content: string): Promise<Message> {
    return apiClient.post(`/chats/${chatId}/messages`, { content });
  },

  // ìŠ¤íŠ¸ë¦¬ë° (SSE í´ë¼ì´ì–¸íŠ¸ í™œìš©)
  streamMessage(chatId: string, messageId: string): EventSource {
    return new EventSource(
      `${process.env.NEXT_PUBLIC_API_BASE_URL}/chats/${chatId}/messages/${messageId}/stream`,
      { withCredentials: true } // HttpOnly ì¿ í‚¤ ì „ì†¡
    );
  },

  // ê³µìœ 
  async shareChat(chatId: string): Promise<{ shareToken: string; shareUrl: string }> {
    return apiClient.post(`/chats/${chatId}/share`);
  },

  async getSharedChat(shareToken: string): Promise<Chat> {
    return apiClient.get(`/share/${shareToken}`);
  },
};
```

**2. React Query í›…**

```typescript
// lib/api/hooks/queries/useChatMessages.ts
import { useInfiniteQuery } from '@tanstack/react-query';
import { chatService } from '../../services/chat';

export function useChatMessages(chatId: string) {
  return useInfiniteQuery({
    queryKey: ['chat', chatId, 'messages'],
    queryFn: ({ pageParam = 0 }) =>
      chatService.getChatMessages(chatId, pageParam, 50),
    getNextPageParam: (lastPage, pages) =>
      lastPage.length === 50 ? pages.length * 50 : undefined,
    enabled: !!chatId,
  });
}

// lib/api/hooks/mutations/useSendMessage.ts
import { useMutation, useQueryClient } from '@tanstack/react-query';
import { chatService } from '../../services/chat';

export function useSendMessage(chatId: string) {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (content: string) =>
      chatService.sendMessage(chatId, content),

    onMutate: async (content) => {
      // Optimistic update
      await queryClient.cancelQueries(['chat', chatId, 'messages']);

      const previous = queryClient.getQueryData(['chat', chatId, 'messages']);

      queryClient.setQueryData(['chat', chatId, 'messages'], (old: any) => ({
        ...old,
        pages: [
          ...old.pages.slice(0, -1),
          [...old.pages[old.pages.length - 1], {
            id: 'temp-' + Date.now(),
            role: 'user',
            content,
            createdAt: new Date().toISOString(),
          }],
        ],
      }));

      return { previous };
    },

    onError: (err, variables, context) => {
      if (context?.previous) {
        queryClient.setQueryData(['chat', chatId, 'messages'], context.previous);
      }
    },

    onSuccess: () => {
      queryClient.invalidateQueries(['chat', chatId, 'messages']);
    },
  });
}

// lib/api/hooks/queries/useStreamingMessage.ts
import { useEffect, useState } from 'react';
import { chatService } from '../../services/chat';

export function useStreamingMessage(chatId: string, messageId: string) {
  const [content, setContent] = useState('');
  const [isComplete, setIsComplete] = useState(false);
  const [error, setError] = useState<Error | null>(null);

  useEffect(() => {
    if (!chatId || !messageId) return;

    const eventSource = chatService.streamMessage(chatId, messageId);

    eventSource.onmessage = (event) => {
      const data = JSON.parse(event.data);

      if (data.type === 'token') {
        setContent(prev => prev + data.content);
      } else if (data.type === 'done') {
        setIsComplete(true);
        eventSource.close();
      }
    };

    eventSource.onerror = (err) => {
      setError(new Error('Stream connection error'));
      eventSource.close();
    };

    return () => eventSource.close();
  }, [chatId, messageId]);

  return { content, isComplete, error };
}
```

**3. ì»´í¬ë„ŒíŠ¸ ì‚¬ìš© ì˜ˆì‹œ**

```typescript
// components/search/ChatInterface.tsx
'use client';

import { useState } from 'react';
import { useRouter } from 'next/navigation';
import { useChatMessages, useSendMessage } from '@/lib/api';

export function ChatInterface({ initialChatId }: { initialChatId?: string }) {
  const router = useRouter();
  const [chatId, setChatId] = useState(initialChatId);

  const { data, fetchNextPage, hasNextPage } = useChatMessages(chatId!);
  const sendMessage = useSendMessage(chatId!);

  const handleSendMessage = async (content: string) => {
    if (!chatId) {
      // ìƒˆ ëŒ€í™” ìƒì„±
      const newChat = await chatService.createChat({ title: content.slice(0, 60) });
      setChatId(newChat.id);

      // URL ì—…ë°ì´íŠ¸ (íˆìŠ¤í† ë¦¬ ì—”íŠ¸ë¦¬ ìƒì„± ì•ˆí•¨)
      window.history.replaceState(
        { chatId: newChat.id },
        '',
        `/search/${newChat.id}`
      );
    }

    sendMessage.mutate(content);
  };

  return (
    <div>
      <MessageList
        messages={data?.pages.flat() ?? []}
        onLoadMore={fetchNextPage}
        hasMore={hasNextPage}
      />
      <MessageInput onSend={handleSendMessage} />
    </div>
  );
}

// components/search/StreamingMessage.tsx
'use client';

import { useStreamingMessage } from '@/lib/api';

export function StreamingMessage({ chatId, messageId }: Props) {
  const { content, isComplete, error } = useStreamingMessage(chatId, messageId);

  if (error) {
    return <ErrorMessage error={error} />;
  }

  return (
    <div className="message">
      <Markdown>{content}</Markdown>
      {!isComplete && <StreamingIndicator />}
    </div>
  );
}
```

**4. Django ë°±ì—”ë“œ API ì—”ë“œí¬ì¸íŠ¸ (ì°¸ê³ )**

```python
# careerly_backend/chat/views.py
from rest_framework import viewsets, status
from rest_framework.decorators import action
from rest_framework.response import Response
from django.http import StreamingHttpResponse
import json
import asyncio

class ChatViewSet(viewsets.ModelViewSet):
    queryset = Chat.objects.all()
    serializer_class = ChatSerializer

    @action(detail=True, methods=['post'])
    def share(self, request, pk=None):
        chat = self.get_object()
        chat.is_shared = True
        chat.share_token = uuid.uuid4()
        chat.save()

        return Response({
            'shareToken': str(chat.share_token),
            'shareUrl': f'/share/{chat.share_token}'
        })

    @action(detail=True, methods=['get'])
    def stream_message(self, request, pk=None, message_id=None):
        """SSE ìŠ¤íŠ¸ë¦¬ë° ì—”ë“œí¬ì¸íŠ¸"""

        def event_stream():
            # AI ì‘ë‹µ ìŠ¤íŠ¸ë¦¬ë°
            for chunk in ai_service.stream_response(message_id):
                yield f"data: {json.dumps({'type': 'token', 'content': chunk})}\n\n"

            yield f"data: {json.dumps({'type': 'done'})}\n\n"

        response = StreamingHttpResponse(
            event_stream(),
            content_type='text/event-stream'
        )
        response['Cache-Control'] = 'no-cache'
        response['X-Accel-Buffering'] = 'no'  # Nginx ë²„í¼ë§ ë¹„í™œì„±í™”

        return response

# urls.py
router.register(r'chats', ChatViewSet)

# ê³µìœ  ë§í¬ ì¡°íšŒ (ë³„ë„ ì—”ë“œí¬ì¸íŠ¸)
path('share/<uuid:share_token>/', SharedChatView.as_view()),
```

---

### 5.3 ì²´í¬ë¦¬ìŠ¤íŠ¸

#### ê¸°ëŠ¥ êµ¬í˜„
- [ ] Chat ë° Message ë°ì´í„° ëª¨ë¸ ì •ì˜
- [ ] ì„œë²„ ì¸¡ Chat ID ìƒì„± API
- [ ] ë©”ì‹œì§€ CRUD API
- [ ] SSE ìŠ¤íŠ¸ë¦¬ë° ì—”ë“œí¬ì¸íŠ¸
- [ ] ë°±ê·¸ë¼ìš´ë“œ ì˜ì†í™” ì‘ì—… í
- [ ] ê³µìœ  ë§í¬ ìƒì„± ë° ì¡°íšŒ API
- [ ] ìµëª… ì„¸ì…˜ â†’ ì¸ì¦ ì„¸ì…˜ ë§ˆì´ê·¸ë ˆì´ì…˜
- [ ] URL ë¼ìš°íŒ… (replaceState/pushState)

#### ì„±ëŠ¥ ìµœì í™”
- [ ] ë°ì´í„°ë² ì´ìŠ¤ ì¸ë±ì‹±
- [ ] ë©”ì‹œì§€ í˜ì´ì§€ë„¤ì´ì…˜
- [ ] Redis ìºì‹±
- [ ] SSE ì¬ì—°ê²° ë¡œì§
- [ ] Optimistic UI ì—…ë°ì´íŠ¸

#### SEO ë° ê³µìœ 
- [ ] Open Graph ë©”íƒ€ íƒœê·¸
- [ ] ë™ì  OG ì´ë¯¸ì§€ ìƒì„±
- [ ] robots.txt ì„¤ì • (AI ë´‡ í—ˆìš©)
- [ ] Structured Data (JSON-LD)
- [ ] Sitemap ìƒì„±

#### ë³´ì•ˆ ë° ì—ëŸ¬ ì²˜ë¦¬
- [ ] ê³µìœ  ë§í¬ ê¶Œí•œ ê²€ì¦
- [ ] Rate limiting
- [ ] ìŠ¤íŠ¸ë¦¼ ì¤‘ë‹¨ ì²˜ë¦¬
- [ ] í´ë¼ì´ì–¸íŠ¸ ì¬ì—°ê²° ë¡œì§
- [ ] ì—ëŸ¬ ë¡œê¹… ë° ëª¨ë‹ˆí„°ë§

#### í…ŒìŠ¤íŠ¸
- [ ] ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ (ì„œë¹„ìŠ¤, í›…)
- [ ] í†µí•© í…ŒìŠ¤íŠ¸ (API ì—”ë“œí¬ì¸íŠ¸)
- [ ] E2E í…ŒìŠ¤íŠ¸ (ì‚¬ìš©ì í”Œë¡œìš°)
- [ ] ìŠ¤íŠ¸ë¦¬ë° ì•ˆì •ì„± í…ŒìŠ¤íŠ¸
- [ ] ë™ì‹œì„± í…ŒìŠ¤íŠ¸ (ë©€í‹°í”Œë ˆì´ì–´)

---

## ì°¸ê³  ë¬¸ì„œ

### URL íŒ¨í„´ ë° ê³µìœ 
- [Perplexity AI's shareable pages - TechCrunch](https://techcrunch.com/2024/05/30/perplexity-ais-new-feature-will-turn-your-searches-into-sharable-pages/)
- [ChatGPT Shared Links FAQ - OpenAI](https://help.openai.com/en/articles/7925741-chatgpt-shared-links-faq)
- [Pushstate vs Replacestate - ThatWare](https://thatware.co/pushstate-vs-replacestate/)

### ID ìƒì„±
- [Generating Id's Server vs Client side - Stack Overflow](https://stackoverflow.com/questions/59966008/generating-ids-server-vs-client-side)
- [Should I generate GUID/UUID on client or server?](https://softwareengineering.stackexchange.com/questions/367347/should-i-generate-guid-uuid-on-client-or-server)

### ìŠ¤íŠ¸ë¦¬ë° + ì˜ì†í™”
- [AI SDK UI: Chatbot Message Persistence](https://ai-sdk.dev/docs/ai-sdk-ui/chatbot-message-persistence)
- [Persistent Text Streaming - Convex](https://www.convex.dev/components/persistent-text-streaming)
- [GPT Streaming with Persistent Reactivity - Convex](https://stack.convex.dev/gpt-streaming-with-persistent-reactivity)
- [Server Sent Events at Scale - Shopify Engineering](https://shopify.engineering/server-sent-events-data-streaming)

### ì„¸ì…˜ ê´€ë¦¬
- [Mastering Google ADK DatabaseSessionService - DEV](https://dev.to/greyisheepai/mastering-google-adk-databasesessionservice-and-events-complete-guide-to-event-injection-and-pdm)
- [Session Continuity - Crisp Chat SDK](https://docs.crisp.chat/guides/chatbox-sdks/web-sdk/session-continuity/)

### ì•„í‚¤í…ì²˜
- [Perplexity AI Architecture - Graph AI](https://www.graphapp.ai/blog/perplexity-technical-deep-dive-understanding-the-complexities)
- [Architecting AI-First Search API - Perplexity](https://www.perplexity.ai/api-platform/resources/architecting-and-evaluating-an-ai-first-search-api)

### SEO
- [GEO Optimization Guide - Passionfruit](https://www.getpassionfruit.com/blog/generative-engine-optimization-guide-for-chatgpt-perplexity-gemini-claude-copilot)
- [AI Search Optimization - Marketing Aid](https://www.marketingaid.io/ai-search-optimization/)

---

## ê²°ë¡ 

AI ê²€ìƒ‰ ì„œë¹„ìŠ¤ì˜ ëŒ€í™” ì˜ì†í™” ë° ê³µìœ  íŒ¨í„´ì€ ë‹¤ìŒ í•µì‹¬ ìš”ì†Œë¡œ êµ¬ì„±ë©ë‹ˆë‹¤:

1. **URL êµ¬ì¡°**: ì„œë²„ ìƒì„± UUID ê¸°ë°˜ permalink (`/search/{id}`, `/share/{id}`)
2. **ID ìƒì„±**: ì„œë²„ ì¸¡ ìƒì„± ê¶Œì¥ (ë¬´ê²°ì„±, ë³´ì•ˆ)
3. **ìŠ¤íŠ¸ë¦¬ë° + ì˜ì†í™”**: ë°ì´í„°ë² ì´ìŠ¤ë¥¼ reactivity layerë¡œ í™œìš©í•œ ë¶„ë¦¬ ì•„í‚¤í…ì²˜
4. **ì €ì¥ íƒ€ì´ë°**: Hybrid ì „ëµ (ë¬¸ì¥ ê²½ê³„ + ì‹œê°„ ê¸°ë°˜ ë°°ì¹˜)
5. **ì„¸ì…˜ ê´€ë¦¬**: ì´ë²¤íŠ¸ ë§ˆì´ê·¸ë ˆì´ì…˜ ë˜ëŠ” í† í° ê¸°ë°˜ ì—°ê²°
6. **ìƒíƒœ ë³µì›**: SSE Last-Event-ID ë˜ëŠ” React Query ìë™ ì¬ì¡°íšŒ

Careerly v2ëŠ” ê¸°ì¡´ API í´ë¼ì´ì–¸íŠ¸ êµ¬ì¡°ë¥¼ í™•ì¥í•˜ì—¬ ì´ëŸ¬í•œ íŒ¨í„´ì„ ì ì§„ì ìœ¼ë¡œ ì ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
